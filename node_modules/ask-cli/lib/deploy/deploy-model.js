'use strict';

const apiWrapper = require('../api/api-wrapper');
const tools = require('../utils/tools');
const jsonUtility = require('../utils/json-utility');
const displayUtil = require('../utils/display-utility');
const CONSTANTS = require('../utils/constants');
const async = require('async');
const path = require('path');
const fs = require('fs');
const retry = require('retry');

// Public
module.exports.deployModel = (skillId, skillInfo, isWaiting, profile, doDebug, callback) => {
    if (!skillId) {
        console.error('[Error]: Cannot find skill ID to deploy the model to.');
        process.exit(1);
    }
    let isModelIncluded = skillInfo.domainList.indexOf('custom') !== -1;
    if (isModelIncluded) {
        let localeList = getModelListFromProject(skillInfo.publishLocaleList);
        if (!localeList || localeList.length === 0) {
            console.log('No model need to be deployed.');
            if (callback && typeof callback === 'function') {
                callback();
            }
            return;
        }

        checkBuildStatus(skillId, localeList, profile, doDebug, () => {
            updateModel(skillId, localeList, profile, doDebug, () => {
                if (isWaiting) {
                    pollingModelStatus(skillId, localeList, profile, doDebug, callback);
                } else {
                    console.log('\nModel submitted. Please use the following command to track the model build status:' +
                                '\n    ask api get-skill-status -s ' + skillId + '\n');
                    if (typeof callback === 'function' && callback) {
                        callback();
                    }
                }
            });
        });
    } else {
        callback();
    }
};


/**
 * Get model list from skill project.
 * Model list should be subset of skillInfo.publishLocaleList
 *
 * @params skillInfo.publishLocaleList
 * @return true list of models to be deployed
 */
function getModelListFromProject(publishLocaleList) {
    let modelFolderPath = path.join(process.cwd(), 'models');
    if (!fs.existsSync(modelFolderPath)) {
        return false;
    }
    let localeList = fs.readdirSync(modelFolderPath).map((file) => {
        return path.basename(file, '.json');
    });
    return localeList.filter((locale) => {
        return publishLocaleList.indexOf(locale) !== -1;
    });
}

function updateModel(skillId, localeList, profile, doDebug, callback) {
    async.eachSeries(localeList, (locale, deployModelCallback) => {
        setTimeout(() => {
            highLevelUpdateModel(skillId, locale, profile, doDebug, () => {
                deployModelCallback();
            });
        }, CONSTANTS.CONFIGURATION.TIME_INTERVAL_FOR_ASYNC_REQUEST);
    }, () => {
        callback();
    });
}

function checkBuildStatus(skillId, localeList, profile, doDebug, callback) {
    let checkBuildStatusSpinner = displayUtil.Spinner(' model status checking...');
    checkBuildStatusSpinner.start();

    apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL], profile, doDebug, (data) => {
        checkBuildStatusSpinner.stop();
        if (data.statusCode === 404) {
            callback();
            return;
        }
        let buildResponse = tools.convertDataToJsonObject(data.body);
        localeList.forEach((locale) => {
            let skillStatusPathToStatus = [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL, locale, 'lastUpdateRequest', 'status'];
            let localeStatus = jsonUtility.getPropertyFromJsonObject(buildResponse, skillStatusPathToStatus);
            if (localeStatus === CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
                console.log('Model build in progress. Please try again when previous build finishes.');
                process.exit();
                return;
            }
        });

        callback();
    });
}

function highLevelUpdateModel(skillId, locale, profile, doDebug, callback) {
    let modelFile = path.join(process.cwd(), 'models', locale + '.json');
    if (!fs.existsSync(modelFile)) {
        console.log("Can't find " + locale + '.json in ./models');
        return;
    }
    let modelSchema = jsonUtility.read(modelFile);
    apiWrapper.callUpdateModel(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, locale, modelSchema, profile, doDebug, callback);
}

/**
 * Entry function for polling status for model building.
 * Will call keepPollingModelBuildStatus to continuously poll.
 *
 * @param skillId
 * @param localeList
 * @param profile
 * @param doDebug
 * @param callback
 */
function pollingModelStatus(skillId, localeList, profile, doDebug, callback) {
    let pollingStatusSpinner = displayUtil.Spinner(' polling the status for all models...');
    pollingStatusSpinner.start();

    keepPollingModelBuildStatus(skillId, localeList, profile, doDebug, (err, failureArray) => {
        pollingStatusSpinner.stop();
        if (err) {
            console.error(err);
            process.exit(1);
        }
        if (failureArray.length !== 0) {
            printOutModelBuildingStatus(failureArray, 'Failure');
            console.error('Deployment process stops due to model buidling failure.');
        } else {
            console.log('Model deployment finished.');
            if (typeof callback === 'function' && callback) {
                callback();
            }
        }
    });
}

/**
 * Polling for model build status every 5 seconds and return with an array of build failed locales
 *
 * @param skillId
 * @param localeList
 * @param profile
 * @param doDebug
 * @param callback result of (err, failureArray)
 */
function keepPollingModelBuildStatus(skillId, localeList, profile, doDebug, callback) {
    // The maximum waiting time, which is the last time's polling will be:
    //   Math.min(minTimeout * Math.pow(1.25, 30), maxTimeout) ~= 1h
    // which is a good estimate for model status polling
    let operation = retry.operation({
        retries: CONSTANTS.CONFIGURATION.RETRY.GET_MODEL_STATUS.MAX_RETRY,
        minTimeout: CONSTANTS.CONFIGURATION.RETRY.GET_MODEL_STATUS.MIN_TIME_OUT,
        factor: CONSTANTS.CONFIGURATION.RETRY.GET_MODEL_STATUS.FACTOR
    });

    let failureArray = [];
    let isRetryFinished = false;
    operation.attempt(() => {
        apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL], profile, doDebug, (data) => {
            if (operation.retry(isRetryFinished ? null : 'needRetry')) {
                if (data.statusCode !== 404) {
                    let buildResponse = tools.convertDataToJsonObject(data.body);
                    localeList.forEach((locale) => {
                        let skillStatusPathToStatus = ['interactionModel', locale, 'lastUpdateRequest', 'status'];
                        let localeStatus = jsonUtility.getPropertyFromJsonObject(buildResponse, skillStatusPathToStatus);
                        if (localeStatus === null) {
                            callback('[Error]: Invalid response for interactionModel status from get-skill-status request.', null);
                            isRetryFinished = true;
                            return;
                        }
                        if (localeStatus === CONSTANTS.SKILL.BUILD_STATUS.FAILURE) {
                            failureArray.push(locale);
                        } else if (localeStatus === CONSTANTS.SKILL.BUILD_STATUS.SUCCESS) {
                            localeList.splice(localeList.indexOf(locale), 1);
                        } else if (localeStatus !== CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
                            callback('[Error]: Invalid response for interactionModel status from get-skill-status request.', null);
                            isRetryFinished = true;
                        }
                    });

                    if (localeList.length === 0) {
                        callback(null, failureArray);
                        isRetryFinished = true;
                    }
                }
            }

            if (operation.attempts() === CONSTANTS.CONFIGURATION.RETRY.GET_MANIFEST_STATUS.MAX_RETRY) {
                callback('[Error]: Polling timeout. The interaction model is still in building progress.', null);
                isRetryFinished = true;
            }
        });
    });
}

function printOutModelBuildingStatus(modelLocaleList, status) {
    for (let locale of modelLocaleList) {
        console.log('[' + status + '] ' + locale);
    }
}
