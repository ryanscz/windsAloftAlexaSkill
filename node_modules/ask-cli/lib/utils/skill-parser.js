'use strict';

const path = require('path');

const domainRegistry = require('./domain-registry');
const jsonUtility = require('./json-utility');


/*
 * Get SkillInfo (Extract CLI relative info from manifest)
 *
 * @params manifest
 * @return skillInfo with following fields
 *       | skillName
 *       | endpointsInfo
 *       | publishLocaleList
 *       | domainList
 *       | hasLambdaFunction
 */
module.exports.extractSkillInfo = (manifest) => {
    let skillInfo = {
        'skillName': module.exports.parseSkillName(manifest),
        'endpointsInfo': module.exports.parseEndpointInfo(manifest),
        'publishLocaleList': module.exports.parsePublishingLocaleList(manifest),
        'domainList': module.exports.parseDomainList(manifest)
    };
    skillInfo.hasLambdaFunction = module.exports.hasLambdaFunction(skillInfo.endpointsInfo);
    if (!skillInfo.skillName || skillInfo.skillName.length === 0) {
        // delete domain check. the check will be done by backend
        return null;
    }
    return skillInfo;
};

/*
 * Get SkillName from manifest
 * Two notes on this function:
 * 1.The name in en-US is prioritized; if no en-US then use the first locale
 * 2.Filter the name by replacing all the invalid character to '-'
 *
 * @params manifest
 * @return skillName
 */
module.exports.parseSkillName = (manifest) => {
    let locales = jsonUtility.getPropertyFromJsonObject(manifest,
        ['manifest', 'publishingInformation', 'locales']);
    if (!locales) {
        locales = jsonUtility.getPropertyFromJsonObject(manifest,
            ['skillManifest', 'publishingInformation', 'locales']);
    }
    if (!locales) {
        return null;
    }
    let name;
    if (locales.hasOwnProperty('en-US')) {
        name = locales['en-US'].name;
    } else if (locales.hasOwnProperty('en-GB')){
        name = locales['en-GB'].name;
    } else {
        name = locales[Object.keys(locales)[0]].name;
    }
    let result = module.exports.filterSkillName(name);
    if (!result || result.length === 0) {
        console.error('Get skill name error. Skill name should not be empty.');
        return null;
    }
    return result;
};

module.exports.parseEndpointInfo = (manifest) => {
    let endpointsInfo = {};
    let domainList = module.exports.parseDomainList(manifest);
    if (!domainList || domainList.length === 0) {
        return endpointsInfo;
    }
    for (let domain of domainList) {
        let domainKey = domainRegistry.getSkillSchemaKey(domain);
        let domainInfo = jsonUtility.getPropertyFromJsonObject(manifest, ['manifest', 'apis', domainKey]);
        if (!domainInfo) {
            domainInfo = jsonUtility.getPropertyFromJsonObject(manifest, ['skillManifest', 'apis', domainKey]);
        }
        if (!domainInfo.hasOwnProperty('endpoint')) {
            continue;
        }

        if (!domainInfo.endpoint) {
            console.error(
                '[Error]: Invalid skill information. Please check skill.json against' +
                ' `.ask/config`. The "merge" object inside the config file will overwrite' +
                ' the existing field in skill.json at runtime.'
            );
            process.exit(1);
        }
        endpointsInfo[domain] = {};

        // Add default region to the list
        endpointsInfo[domain]['default'] = {};
        if (domainInfo.endpoint.hasOwnProperty('uri')) {
            endpointsInfo[domain]['default'].uri = domainInfo.endpoint.uri;
        }
        if (domainInfo.endpoint.hasOwnProperty('sourceDir')) {
            endpointsInfo[domain]['default'].sourceDir = domainInfo.endpoint.sourceDir;
        }
        if (Object.keys(endpointsInfo[domain]['default']).length === 0) {
            delete endpointsInfo[domain]['default'];
        }

        // Add endpoints in the 'regions' field. Only check 'regions' when default 'endpoint' exists
        if (domainInfo.hasOwnProperty('regions')) {
            let regionInfo = domainInfo.regions;
            for (let region of Object.getOwnPropertyNames(regionInfo)) {
                if (!regionInfo[region].hasOwnProperty('endpoint')) {
                    continue;
                }
                let endpointInfoForRegion = regionInfo[region].endpoint;
                endpointsInfo[domain][region] = {};
                if (endpointInfoForRegion.hasOwnProperty('uri')) {
                    endpointsInfo[domain][region].uri = endpointInfoForRegion.uri;
                }
                if (endpointInfoForRegion.hasOwnProperty('sourceDir')) {
                    endpointsInfo[domain][region].sourceDir = endpointInfoForRegion.sourceDir;
                }
                if (Object.keys(endpointsInfo[domain][region]).length === 0) {
                    delete endpointsInfo[domain][region];
                }
            }
        }


        // Delete the domain which doesn't have details in endpoint field
        if (Object.keys(endpointsInfo[domain]).length === 0) {
            delete endpointsInfo[domain];
        }
    }
    return endpointsInfo;
};

module.exports.parseDomainList = (manifest) => {
    let apis = jsonUtility.getPropertyFromJsonObject(manifest, ['manifest', 'apis']);
    if (!apis) {
        apis = jsonUtility.getPropertyFromJsonObject(manifest, ['skillManifest', 'apis']);
    }
    if (!apis) {
        return null;
    }
    if (Object.keys(apis).length < 1) {
        console.warn('Skill.json invalid. Skill domain not specified.');
        return null;
    }

    let domainList = [];
    for (let domain of domainRegistry.domainList()) {
        let domainKey = domainRegistry.getSkillSchemaKey(domain);
        if (apis.hasOwnProperty(domainKey)) {
            domainList.push(domain);
        }
    }
    return domainList;
};

module.exports.hasLambdaFunction = (endpointsInfo) => {
    if (!endpointsInfo || (endpointsInfo.constructor === Object && Object.keys(endpointsInfo).length === 0)) {
        return false;
    }
    for (let domain of Object.getOwnPropertyNames(endpointsInfo)) {
        for (let region of Object.getOwnPropertyNames(endpointsInfo[domain])) {
            if (endpointsInfo[domain][region].sourceDir && endpointsInfo[domain][region].sourceDir.length !== 0) {
                return true;
            }
            let uri = endpointsInfo[domain][region].uri;
            if (uri && uri.startsWith('arn:')) {
                return true;
            }
        }
    }
    return false;
};

module.exports.parsePublishingLocaleList = (manifest) => {
    let publishingLocalesInfo = jsonUtility.getPropertyFromJsonObject(manifest,
        ['manifest', 'publishingInformation', 'locales']);
    if (!publishingLocalesInfo) {
        publishingLocalesInfo = jsonUtility.getPropertyFromJsonObject(manifest,
            ['skillManifest', 'publishingInformation', 'locales']);
    }
    if (!publishingLocalesInfo) {
        return null;
    }
    return Object.keys(publishingLocalesInfo);
};

module.exports.isSkillNameValid = (name) => {
    let filteredName = name.match(/([a-zA-Z0-9-_]+)/g);
    if (filteredName && filteredName[0] === name) {
        return true;
    } else {
        return false;
    }
};

module.exports.isValidLambdaFunctionName = (functionName) => {
    if (functionName.length === 0) {
        return false;
    }
    let re = /[a-zA-Z0-9-_]+/;
    let capturedStringArray = functionName.match(re);
    return functionName.length === capturedStringArray[0].length ? true : false;
};

module.exports.isAbsoluteURL = (url) => {
    let lambdaRegex = /arn:aws:lambda:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?/;
    if (url && (url.substr(0, 6) === 'https:'  || lambdaRegex.test(url))) {
        return true;
    }
    return false;
};

/*
 * Filter the name by replacing all the invalid character to '_'
 *
 * @params skillName
 * @return filteredName
 */
module.exports.filterSkillName = (name) => {
    return name.replace(/[^a-zA-Z0-9-_]+/g, '_');
};

module.exports.reorganizeToObjectList = (endpointsInfo) => {
    let listOfLambdaMetaDataObject = [];
    for (let domain of Object.keys(endpointsInfo)) {
        let reversedMap = reverseKeyValue(endpointsInfo[domain]);
        if (Object.keys(reversedMap).length === 0) {
            continue;
        } else if (Object.keys(reversedMap).length ===1) {
            let addingObject = {};
            addingObject.sourceDirFromDomainLevel = domain;
            addingObject.domain = domain;
            addingObject.regions = reversedMap[Object.keys(reversedMap)[0]];
            addingObject.uri = Object.keys(reversedMap)[0];
            listOfLambdaMetaDataObject.push(addingObject);
        } else {
            for (let arn of Object.keys(reversedMap)) {
                let addingObject = {};
                let regionList = reversedMap[arn];
                let littlePath = path.join(domain, regionList.join('-'));
                addingObject.sourceDirFromDomainLevel = littlePath;
                addingObject.domain = domain;
                addingObject.regions = regionList;
                addingObject.uri = arn;
                listOfLambdaMetaDataObject.push(addingObject);
            }
        }
    }
    return listOfLambdaMetaDataObject;
};

function reverseKeyValue(domainObject) {
    let reversedObject = {};
    for (let region of Object.keys(domainObject)) {
        if (domainObject[region].uri.startsWith('https://')) {
            continue;
        }
        if (!reversedObject.hasOwnProperty(domainObject[region].uri)) {
            reversedObject[domainObject[region].uri] = [];
        }
        reversedObject[domainObject[region].uri].push(region);
    }
    return reversedObject;
}
